# 2024-01-29
mainブランチがいつの間にか動作しなくなってしまった（画面が激しくちらつく。libstdc++からlibc++を使うようにしたせい？）。
なので「libc++」ブランチを切って、徐々にlibc++に対応させている途中なのが現状。
mainの方ですでに適用しているCamera.cppなども改めて適用し直したい。

## 方針の転換
遡って順にやっていけばlibc++にも対応できるかと思ったが、原因不明で気まぐれに画面がおかしくなってしまうらしい。
libc++およびclang17以降（c++23）に対応するのは一旦諦め、clang16とlibstdc++でのビルドに戻すことにする。
残念ではあるが、しかしそもそもの動機はclang15以前ではテンプレート周りでバグがあったため、もっと上のバージョンにしようというものであったのだから、clang16でも何ら問題は無いだろう。

## worldをいちいち指定するのが冗長すぎる
あらゆるWorldObjectのコンストラクタでworldを明示しないといけないのは煩わしい。
現状の設計は、親のいないWorldObjectも描画と更新が可能であるという利点を持つ。
しかしそもそも親がいないオブジェクトというのはナンセンスであるし、それが描画できてしまうというのもむしろ混乱を生む。
それよりもあらゆるノードはメモリの所有権も含め管理する親が必ずいるものとしたほうが、デザインとして優れているかもしれない。

## 継承か合成か
WorldObjectやDrawableを継承するのではなく、WorldObjectにユーザ領域として使えるAny型メンバ変数を持たせたり、関数オブジェクト型のメンバ変数drawを持たせるというやり方も考えられる。しかし、以下の理由から継承を用いるのが妥当だと考えている。
- 継承してメンバ変数を追加したほうが、変数名が明確で分かりやすい。
- せっかくC++を使っているのだから
…とここまで書いて思ったが、DrawableおよびUpdateは継承オーバーロードよりもメンバ変数としてラムダ式で指定できたほうが、簡潔で便利かつユーザ領域変数と描画/更新関数の関連を切り離せるため柔軟性があって優れている。
いやさらに言えば、描画関数をメンバ変数ではなくworldに直接登録できるようにし、Draw抽象クラスのコンストラクタ内で自動で登録される、もしくは手動でカスタム関数を登録できるという2種類の方法を用意するのがリッチかもしれない。手動で登録したものは手動で開放する必要があるが。


# 2024-01-31
エラーコード1282(GL_INVALID_OPERATION)が出ていた問題を修正した。
原因は`glVertexAttribPointer()`関数でシェーダへuv属性を送る時、VBOを利用せずに直接static変数へのポインタを渡していることだったようだ。これだと幸か不幸か動作こそしてくれるものの、エラーコードは発行されてしまうらしい。
対策として、応急処置というかより望ましい形に近づけるために`setAttribute`を呼ぶ位置だけ変えておいたものの、肝心のuv座標の値自体はめちゃくちゃな状態となっているため要修正。

これからやること
- line.cppの実行時、プログラムの終了時に "malloc(): unsorted double linked list corrupted" などのメモリ関連のエラーが出る問題を修正していく。おそらくsetIntervalで立てた別スレッドの寿命が長すぎて、main関数側の変数が解放されたあとにアクセスしようとするのが原因。マルチスレッドをそもそもやめてglfwのメインループ内で動作するタイマー機構を作る。
- タイマー処理をメインループ内に移したところ、やはりメモリエラーは起こらなくなった。Timer.cppは一度白紙にする。
- ループ毎に呼び出す描画処理もタイマーに変更。ブロッキングされてタイマーの実行を妨げるため、垂直同期はOFFにするしかない。


# 2024-02-02
`Window`クラスを`GUI`に名前変更。
インスタンス名が`window`のままになっているのは順次修正する。

# 2024-02-06
ようやくメモリエラーの完全解決を見た。原因は、Updateたちのデストラクタよりも先にWorldのメンバ変数（updateで呼び出す関数一覧もこの一つ）が解放されてしまうことだった。メンバ変数が解放された後でもsize()など一部の関数は動いてしまうのが非常に混乱を招いていた。解決策として、Worldのデストラクタにて子ノードたちを明示的に解放するようにした。

描画処理は垂直同期に合わせたまま、更新処理のみを時間のみに基づいて（UnityのFixedUpdateと同様）動かしたところ、かなりカクついてしまうことが確認できた。垂直同期をオフにして全てをタイマー上に乗せるのは無理があると直感した。


# 2024-03-31
インスタンシングによる描画に成功。attribute変数としてmat4を渡す方法に手こずった。[これ](https://stackoverflow.com/a/17355139/22234700)で解決。ところでVAOを毎フレーム作りなおすようにして解放もしないため、メモリリークの問題が残ってしまった。

# 2024-04-04
MeshObjectのモデル行列を毎フレーム集積するのではなく常にVBOに同期するよう作成・変更・削除を見張るようにすることで、特に静的な物体に関しては劇的なパフォーマンス向上を達成できた。500倍の個数にしてもへっちゃら（作成には超時間がかかるが）。VRAMへのコピー時間は全くと行っていいほどボトルネックにはならないらしい。
バグで手こずったが、原因は
```
if (obs.initial_list.size() != 0 || obs.delete_list.size() != 0)
```
の部分。`||`を`&&`にしてしまっていた。


# 2024-04-07
オブジェクトの複製を行えるようにしたいが、virtualなコンストラクタというものが認められていないせいで、各オブジェクトの実際の型である派生クラスのコピーコンストラクタを多相的に呼び出すことができない。"仮想コンストラクタ"デザインパターンとして`clone()`という仮想関数を用意する手もあるが、派生クラスの実装者がいちいちポインタをキャストしたり親clone関数を明示的に呼びなさなければならないなど、面倒事が多い。
そこで設計を根本から見直し、コンポーネント指向にすることでこの問題を含む数々の不満点を解消する。`Component`クラスを継承すると、そのクラスはコンポーネントとなる。


# 2024-09-25
solでメンバ変数の公開がうまくできない。もしかしたらclang18のバグかも？<https://github.com/ThePhD/sol2/issues/1581>
ブロック崩しがさまになってきた。solがとても便利で、Luaをゲーム専用言語に変えてくれるかのよう。
物理演算も外部ライブラリ（Box2D）を使うことにした。衝突判定の作り方や剛体の管理の仕方など、自力での物理演算で学べたことは多くあったが、高機能かつモジュール性の高いBox2Dは便利だった。移行の障壁も意外と低かった。
コンポーネント指向にしてから一気に進んだ気がする。継承を使いまくるより、インターフェースでフラットにまとめたほうがいいということを実感した。仮想関数のオーバーライドでなく、関数オブジェクトを渡せばそれで済む。従来のやり方は、ラムダ式が無かった時代の遺物のようにすら思えてきた。

開発のノウハウも見えてきた。
新機能の実装にはさほど時間は掛からない。時間を食われるのは圧倒的にバグ潰しのときだ。実行時エラー（特に物体やコンポーネントの削除タイミングによるもの）の解決には丸一日かかる勢いだ。結局全部遅延削除することで解決したのだが、初めからこうなることを予見できていればかなりの時短になったはず。初期段階での設計の重要さを学んだ。


# 2024-09-28
弾を発射したとき、発射位置に弾が張り付いて表示され続けてしまうバグを修正した。
剛体コンポーネントとは別に、Worldがその参照をBufferedSetで管理している。そこに前フレームに削除要請があった剛体（アドレス値）が次フレームですぐさま使い回されて登録要請があったとき、競合が発生してしまっていた。ヒープの空きスペースに、即座に新たなオブジェクトが配置されることがあるというのは驚いた。
フレームの最後に明示的にflushしておくことで解決。
